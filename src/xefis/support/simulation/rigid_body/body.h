/* vim:ts=4
 *
 * Copyleft 2019  Micha≈Ç Gawron
 * Marduk Unix Labs, http://mulabs.org/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for more information on licensing.
 */

#ifndef XEFIS__SUPPORT__SIMULATION__RIGID_BODY__BODY_H__INCLUDED
#define XEFIS__SUPPORT__SIMULATION__RIGID_BODY__BODY_H__INCLUDED

// Standard:
#include <cstddef>
#include <list>
#include <memory>
#include <mutex>
#include <optional>

// Neutrino:
#include <neutrino/noncopyable.h>
#include <neutrino/numeric.h>
#include <neutrino/stdexcept.h>

// Xefis:
#include <xefis/config/all.h>
#include <xefis/support/earth/air/atmosphere_model.h>
#include <xefis/support/math/geometry.h>
#include <xefis/support/math/placement.h>
#include <xefis/support/nature/acceleration_moments.h>
#include <xefis/support/nature/force_moments.h>
#include <xefis/support/nature/mass_moments.h>
#include <xefis/support/nature/velocity_moments.h>
#include <xefis/support/nature/wrench.h>
#include <xefis/support/simulation/rigid_body/concepts.h>
#include <xefis/support/simulation/rigid_body/shape.h>


namespace xf::rigid_body {

/**
 * A set of calculations related to the body done by the simulator on each frame.
 */
class BodyFrameCache
{
  public:
	SpaceMatrix<si::Mass, WorldSpace>::InversedMatrix				inv_M;
	SpaceMatrix<si::MomentOfInertia, WorldSpace>::InversedMatrix	inv_I;
	ForceMoments<WorldSpace>										gravitational_force_moments;
	ForceMoments<WorldSpace>										external_force_moments; // Excluding gravitation.
	ForceMoments<WorldSpace>										constraint_force_moments;
	// Those are used temporarily when converging constraint_force_moments:
	AccelerationMoments<WorldSpace>									acceleration_moments;
	VelocityMoments<WorldSpace>										velocity_moments;

  public:
	ForceMoments<WorldSpace>
	all_force_moments() const noexcept
		{ return gravitational_force_moments + external_force_moments + constraint_force_moments; }
};


/**
 * Rigid body.
 */
class Body: public Noncopyable
{
  public:
	enum ShapeType
	{
		ShapeIsConstant,
		ShapeChanges,
	};

  public:
	// Dtor
	virtual
	~Body() = default;

  public:
	// Ctor
	template<class MassMomentsSpace>
		Body (MassMoments<MassMomentsSpace> const&, ShapeType = ShapeIsConstant);

	/**
	 * Return mass moments at center-of-mass.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		MassMoments<Space>
		mass_moments() const;

	/**
	 * Set new mass moments at center-of-mass.
	 */
	template<CoordinateSystemConcept Space>
		void
		set_mass_moments (MassMoments<Space> const&);

	/**
	 * Return location of center-of-mass.
	 * Use world frame of reference and world space coordinates.
	 */
	[[nodiscard]]
	Placement<WorldSpace, BodySpace> const&
	location() const noexcept
		{ return _location; }

	/**
	 * Set new location of center-of-mass.
	 */
	void
	set_location (Placement<WorldSpace, BodySpace> const& location) noexcept
		{ _location = location; }

	/**
	 * Return velocity moments of this part in the absolute frame of reference.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		VelocityMoments<Space> const&
		velocity_moments() const;

	/**
	 * Set new velocity moments of center-of-mass.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		void
		set_velocity_moments (VelocityMoments<Space> const&);

	/**
	 * Return acceleration moments of center-of-mass.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		AccelerationMoments<Space> const&
		acceleration_moments() const;

	/**
	 * Set new acceleration moments of center-of-mass.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		void
		set_acceleration_moments (AccelerationMoments<Space> const&);

	/**
	 * Return total external force moments generated by this object at the center-of-mass.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		ForceMoments<Space> const&
		external_force_moments() const;

	/**
	 * Apply force at center-of-mass for the duration of the following simulation frame.
	 * It will be treated as external force-moments for this body.
	 * Multiple calls add new forces instead of overwriting last one.
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		void
		apply_force (ForceMoments<Space> const& force_moments);

	/**
	 * Apply force at center-of-mass for the duration of the following simulation frame.
	 * See remarks for apply_force (ForceMoments<Space>).
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept ForceSpace, CoordinateSystemConcept PositionSpace>
		void
		apply_force (ForceMoments<ForceSpace> const& force_moments, SpaceLength<PositionSpace> const& position);

	/**
	 * Apply force for the duration of the following simulation frame.
	 * Wrench should be relative to body's center-of-mass.
	 * See remarks for apply_force (ForceMoments<Space>).
	 * Use world frame of reference and provided Space coordinate system.
	 */
	template<CoordinateSystemConcept Space>
		void
		apply_force (Wrench<Space> const& wrench);

	/**
	 * Resets all applied forces.
	 */
	void
	reset_applied_forces() noexcept;

	/**
	 * Return body's shape.
	 * It should be assumet it can change from frame to frame unless shape_is_constant()
	 * returns true.
	 */
	[[nodiscard]]
	std::optional<Shape> const&
	shape() const noexcept
		{ return _shape; }

	/**
	 * Set body shape. Shape's origin will be placed at body's center of mass.
	 */
	void
	set_shape (std::optional<Shape> const&);

	/**
	 * Set body shape.
	 */
	void
	set_shape (std::optional<Shape>&& shape)
		{ _shape = std::move (shape); }

	/**
	 * Return true if shape() never changes and can be cached by the caller.
	 */
	[[nodiscard]]
	bool
	shape_is_constant() const noexcept
		{ return _shape_type == ShapeIsConstant; }

	/**
	 * Origin vector in chosen Space coordinate system and world frame of reference.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		SpaceLength<Space>
		origin() const;

	/**
	 * Origin-to-center of mass vector in Space coordinate system and world frame of reference.
	 */
	template<CoordinateSystemConcept Space>
		[[nodiscard]]
		SpaceLength<Space>
		origin_to_center_of_mass() const noexcept;

	/**
	 * Set origin at (relative to center-of-mass) in BodySpace coordinate system
	 * and world frame of reference.
	 */
	void
	set_origin_at (SpaceLength<BodySpace> const& vector)
		{ _origin_position = vector; }

	/**
	 * Rotate the body about it's center of mass by provided rotation matrix.
	 */
	void
	rotate_about_center_of_mass (RotationMatrix<WorldSpace> const&);

	/**
	 * Rotate the body about world space origin by provided rotation matrix.
	 */
	void
	rotate_about_world_origin (RotationMatrix<WorldSpace> const&);

	/**
	 * Rotate the body about the body origin.
	 */
	void
	rotate_about_body_origin (RotationMatrix<WorldSpace> const&);

	/**
	 * Rotate the body about given point.
	 */
	void
	rotate_about (SpaceLength<WorldSpace> const& about_point, RotationMatrix<WorldSpace> const&);

	/**
	 * Translate the body by given vector.
	 */
	void
	translate (SpaceLength<WorldSpace> const&);

	/**
	 * Translate the body so that its center of mass is at newly given point.
	 */
	void
	move_to (SpaceLength<WorldSpace> const& new_position);

	/**
	 * Translate the body so that its origin is at newly given point.
	 */
	void
	move_origin_to (SpaceLength<WorldSpace> const& new_origin_position);

	/**
	 * Calculate total kinetic energy of the body in WorldSpace frame of reference.
	 */
	si::Energy
	kinetic_energy() const;

	/**
	 * Return center of mass vector of the argument from the most recent call
	 * to set_mass_moments().
	 *
	 * When set_mass_moments() is called, it offsets the provided MassMoments<> by the center of mass
	 * so that it's at the origin of BodySpace. The original center of mass position is
	 * returned by this function.
	 */
	SpaceLength<BodySpace>
	last_center_of_mass() const noexcept
		{ return _saved_center_of_mass; }

	/**
	 * Return frame cache of the body.
	 * To be used by the simulator.
	 */
	[[nodiscard]]
	BodyFrameCache&
	frame_cache() noexcept
		{ return _frame_cache; }

	/**
	 * Return frame cache of the body.
	 * To be used by the simulator.
	 */
	[[nodiscard]]
	BodyFrameCache const&
	frame_cache() const noexcept
		{ return _frame_cache; }

	/**
	 * Evolve the body (eg. change the shape if it's changeable).
	 */
	virtual void
	evolve ([[maybe_unused]] si::Time dt)
	{ }

	/**
	 * Ask body to update external force moments by calling apply_force() methods.
	 */
	virtual void
	update_external_forces (AtmosphereModel const*)
	{ }

  private:
	MassMoments<BodySpace>									_mass_moments;
	mutable std::optional<MassMoments<WorldSpace>>			_world_space_mass_moments;
	SpaceLength<BodySpace>									_saved_center_of_mass;
	SpaceLength<BodySpace>									_origin_position;
	// Location of center-of-mass:
	Placement<WorldSpace, BodySpace>						_location;
	// Velocity of center-of-mass:
	VelocityMoments<WorldSpace>								_velocity_moments;
	mutable std::optional<VelocityMoments<BodySpace>>		_body_space_velocity_moments;
	// Acceleration moments of center-of-mass:
	AccelerationMoments<WorldSpace>							_acceleration_moments;
	mutable std::optional<AccelerationMoments<BodySpace>>	_body_space_acceleration_moments;
	// Impulses applied for the duration of the simulation frame:
	mutable std::optional<ForceMoments<WorldSpace>>			_world_space_applied_forces;
	ForceMoments<BodySpace>									_applied_forces;
	// Stuff calculated when simulation is run:
	BodyFrameCache											_frame_cache;
	// Body shape:
	std::optional<Shape>									_shape;
	ShapeType												_shape_type;
	// Mutex for all those _world_space_* and _body_space_* optionals:
	mutable std::mutex										_optionals_mutex;
};


template<class MassMomentsSpace>
	inline
	Body::Body (MassMoments<MassMomentsSpace> const& mass_moments, ShapeType const shape_type):
		_shape_type (shape_type)
	{
		set_mass_moments (mass_moments);
	}


template<CoordinateSystemConcept Space>
	inline MassMoments<Space>
	Body::mass_moments() const
	{
		if constexpr (std::is_same_v<Space, WorldSpace>)
		{
			std::lock_guard lock (_optionals_mutex);

			if (!_world_space_mass_moments)
				_world_space_mass_moments = _location.bound_transform_to_base (_mass_moments);

			return *_world_space_mass_moments;
		}
		else if constexpr (std::is_same_v<Space, BodySpace>)
			return _mass_moments;
	}


template<CoordinateSystemConcept Space>
	inline void
	Body::set_mass_moments (MassMoments<Space> const& mass_moments)
	{
		_world_space_mass_moments.reset();

		if constexpr (std::is_same_v<Space, WorldSpace>)
			_mass_moments = _location.bound_transform_to_body (mass_moments);
		else if constexpr (std::is_same_v<Space, BodySpace>)
			_mass_moments = mass_moments;

		_saved_center_of_mass = _mass_moments.center_of_mass_position();
		// Make a correction so that _mass_moments are viewed from the center-of-mass:
		_mass_moments = _mass_moments - _saved_center_of_mass;
	}


template<CoordinateSystemConcept Space>
	inline VelocityMoments<Space> const&
	Body::velocity_moments() const
	{
		if constexpr (std::is_same_v<Space, WorldSpace>)
			return _velocity_moments;
		else if constexpr (std::is_same_v<Space, BodySpace>)
		{
			std::lock_guard lock (_optionals_mutex);

			if (!_body_space_velocity_moments)
				_body_space_velocity_moments = _location.unbound_transform_to_body (_velocity_moments);

			return *_body_space_velocity_moments;
		}
	}


template<CoordinateSystemConcept Space>
	inline void
	Body::set_velocity_moments (VelocityMoments<Space> const& velocity_moments)
	{
		_body_space_velocity_moments.reset();

		if constexpr (std::is_same_v<Space, WorldSpace>)
			_velocity_moments = velocity_moments;
		else if constexpr (std::is_same_v<Space, BodySpace>)
			_velocity_moments = _location.unbound_transform_to_base (velocity_moments);
	}


template<CoordinateSystemConcept Space>
	inline AccelerationMoments<Space> const&
	Body::acceleration_moments() const
	{
		if constexpr (std::is_same_v<Space, WorldSpace>)
			return _acceleration_moments;
		else if constexpr (std::is_same_v<Space, BodySpace>)
		{
			std::lock_guard lock (_optionals_mutex);

			if (!_body_space_acceleration_moments)
				_body_space_acceleration_moments = _location.unbound_transform_to_body (_acceleration_moments);

			return *_body_space_acceleration_moments;
		}
	}


template<CoordinateSystemConcept Space>
	inline void
	Body::set_acceleration_moments (AccelerationMoments<Space> const& acceleration_moments)
	{
		_body_space_acceleration_moments.reset();

		if constexpr (std::is_same_v<Space, WorldSpace>)
			_acceleration_moments = acceleration_moments;
		else if constexpr (std::is_same_v<Space, BodySpace>)
			_acceleration_moments = _location.unbound_transform_to_base (acceleration_moments);
	}


template<CoordinateSystemConcept Space>
	inline ForceMoments<Space> const&
	Body::external_force_moments() const
	{
		if constexpr (std::is_same_v<Space, WorldSpace>)
		{
			std::lock_guard lock (_optionals_mutex);

			if (!_world_space_applied_forces)
				_world_space_applied_forces = _location.unbound_transform_to_base (_applied_forces);

			return *_world_space_applied_forces;
		}
		else if constexpr (std::is_same_v<Space, BodySpace>)
			return _applied_forces;
	}


template<CoordinateSystemConcept Space>
	inline void
	Body::apply_force (ForceMoments<Space> const& force_moments)
	{
		_world_space_applied_forces.reset();

		if constexpr (std::is_same_v<Space, WorldSpace>)
			_applied_forces += _location.unbound_transform_to_body (force_moments);
		else if constexpr (std::is_same_v<Space, BodySpace>)
			_applied_forces += force_moments;
	}


template<CoordinateSystemConcept ForceSpace, CoordinateSystemConcept PositionSpace>
	inline void
	Body::apply_force (ForceMoments<ForceSpace> const& force_moments, SpaceLength<PositionSpace> const& position)
	{
		_world_space_applied_forces.reset();

		ForceMoments<BodySpace> body_space_force_moments;
		SpaceLength<BodySpace> body_space_position;

		if constexpr (std::is_same_v<ForceSpace, WorldSpace>)
			body_space_force_moments = _location.unbound_transform_to_body (force_moments);
		else
			body_space_force_moments = force_moments;

		if constexpr (std::is_same_v<PositionSpace, WorldSpace>)
			body_space_position = _location.bound_transform_to_body (position);
		else
			body_space_position = position;

		apply_force (Wrench (body_space_force_moments, body_space_position));
	}


template<CoordinateSystemConcept Space>
	inline void
	Body::apply_force (Wrench<Space> const& wrench)
	{
		_world_space_applied_forces.reset();

		if constexpr (std::is_same_v<Space, WorldSpace>)
		{
			// The resultant_force() assumes origin as the center of mass, so for Wrenches in WorldSpace coordinates
			// it gives incorrect results, since C.O.M. is rarely at the WorldSpace origin.
			// So first transform Wrench with its position to BodySpace, only then calculate resultant force.
			_applied_forces += resultant_force (_location.bound_transform_to_body (wrench));
		}
		else if constexpr (std::is_same_v<Space, BodySpace>)
			_applied_forces += resultant_force (wrench);
	}


inline void
Body::reset_applied_forces() noexcept
{
	_applied_forces = ForceMoments<BodySpace>();
	_world_space_applied_forces.reset();
}


inline void
Body::set_shape (std::optional<Shape> const& shape)
{
	auto copy = shape;
	set_shape (std::move (shape));
}


template<CoordinateSystemConcept Space>
	inline SpaceLength<Space>
	Body::origin() const
	{
		if constexpr (std::is_same_v<Space, WorldSpace>)
			return _location.bound_transform_to_base (_origin_position);
		else if constexpr (std::is_same_v<Space, BodySpace>)
			return _origin_position;
	}


template<CoordinateSystemConcept Space>
	inline SpaceLength<Space>
	Body::origin_to_center_of_mass() const noexcept
	{
		if constexpr (std::is_same_v<Space, BodySpace>)
			return -_origin_position;
		else if constexpr (std::is_same_v<Space, WorldSpace>)
			return _location.unbound_transform_to_base (-_origin_position);
	}


inline void
Body::rotate_about (SpaceLength<WorldSpace> const& about_point, RotationMatrix<WorldSpace> const& rotation)
{
	_location.rotate_base_frame_about (about_point, rotation);
}


inline void
Body::translate (SpaceLength<WorldSpace> const& translation)
{
	_location.translate_frame (translation);
}


inline void
Body::move_to (SpaceLength<WorldSpace> const& new_position)
{
	_location.set_position (new_position);
}


inline void
Body::move_origin_to (SpaceLength<WorldSpace> const& new_origin_position)
{
	move_to (new_origin_position + origin_to_center_of_mass<WorldSpace>());
}

} // namespace xf::rigid_body

#endif

